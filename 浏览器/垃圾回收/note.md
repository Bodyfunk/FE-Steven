## 垃圾回收
> 总结自《JavaScript高级程序设计(红宝书)》

- 两种标记策略
- 性能
- 内存管理

JavaScript 是垃圾回收语言，执行环境在执行代码的同时也会管理内存。

基本思路：确定哪个变量不会再使用，然后释放它所占用的内存。这个过程是周期性的。

### 两种标记策略
如何标记未使用的变量有许多不同的实现方式，在浏览器发展史上用到的两种主要标记策略： `标记清理(当下主流)`，`引用计数`。

**1. 标记清理**

对变量在上下文中进行标记；例如实现一个标记是否在上下文的列表。

标记过程的实现并不重要，重要的是策略。

**2. 引用计数**

思路是对每个值都记录它被应用的次数。

> 问题：循环引用问题。

### 性能
垃圾回收程序会`周期性`运行，如果内存中分配了很多变量，则可能会造成性能损失，因此垃圾回收时间调度很重要。在内存有限的设备（如移动端），垃圾回收可能会明显拖慢渲染速度和帧速率。但开发者并不知道浏览器引擎什么时候会进行垃圾收集，因此最好的办法是在写代码的时候就要做到：**无论什么时候开始收集垃圾，都能让它尽快结束工作**。

### 内存管理
优化内存占用的最佳手段就是**保证在执行代码时只保存必要的数据**。如果数据不再必要，那么把它设置为`null`，从而释放其引用，这也叫`解除引用`。

#### 内存泄漏
JavaScript中的内存泄漏大部分是由不合理的引用导致的。

**1. 意外声明全局变量是最常见但也是最容易修复的内存泄漏**
```javascript
function setName(){
  name = 'Jake'
}
```
`name`会被当做window属性来创建，只要window不被清理，就不会消失。

**2. 定时器也可能会悄悄导致内存泄漏**
```javascript
let name = 'Jake';
setInterval(()=>{
  console.log(name);
}, 100)
```
只要定时器一直运行，回调函数中引用的`name`就会一直占用内存。

**3. 使用JavaScript闭包很容易在不知不觉间造成内存泄漏**
```javascript
let outer = function(){
  let name = 'Jake';
  return function(){
    return name;
  }
}
```
调用`outer()`会导致分配给`name`的内存泄漏。如果`name`的内容很大，这个闭包可能会导致性能问题。